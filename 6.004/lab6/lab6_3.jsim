.include "nominal.jsim"
.include "stdcell.jsim"
.include "alu.jsim"
.include "lab6checkoff.jsim"

//---------------PC-------------------

// five-way 32-bit mux
.subckt mux5_32 sel[2:0] a[31:0] b[31:0] c[31:0] d[31:0] e[31:0] out[31:0]
Xmux1 sel0#32 sel1#32 a[31:0] b[31:0] c[31:0] d[31:0] int[31:0] mux4
Xmux2 sel2#32 int[31:0] e[31:0] out[31:0] mux2
.ends

.subckt pc clk reset pcsel[2:0] xadr[31:0] illop[31:0] jt[31:0] c[31:0] ia[31:0] cplus[31:0] iaplusfour[31:0]

Xand ia[31] jt[31] newpc31 and2
Xadd ia[31:0] 0#29 vdd 0#2 0 iaplusfour[31:0] z1 v1 n1 add32bit 
Xadd2 iaplusfour[31:0] c[29:0] 0 0 0 cplus[31:0] z2 v2 n2 add32bit

xmux1 pcsel[0]#32 pcsel[1]#32 iaplusfour[31:0] ia[31] cplus[30:0] newpc31 jt[30:2] 0#2 illop[31:0] int[31:0] mux4
xmux2 int[31:0] xadr[31:0] temp[31:0] mux2

Xreset reset#32 temp[31:0] vdd 0#31 next[31:0] mux2
Xdreg next[31:0] clk#32 ia[31:0] dreg
.ends

//-----------REGFILE-----------------

// Check to see if A[4:0] is 31
.subckt andfive A[4:0] out
Xand1 A[4:2] out1 and3
Xand2 A[1:0] out2 and2
Xand3 out1 out2 out and2
.ends

.subckt regfile clk werf ra2sel ra[4:0] rb[4:0] rc[4:0]
+ wdata[31:0] radata[31:0] rbdata[31:0] wasel
Xmux ra2sel#5 rb[4:0] rc[4:0] ra2mux[4:0] mux2

// WASEL mux
Xxp vdd#4 0 xp[4:0] knex
Xwasel wasel#5 rc[4:0] xp[4:0] wa[4:0] mux2

Xregfile
+ vdd 0 0 ra[4:0] adata[31:0]     // A read port
+ vdd 0 0 ra2mux[4:0] bdata[31:0] // B read port
+ 0 clk werf wa[4:0] wdata[31:0]  // write port
+ $memory width=32 nlocations=31
Xcheck31a ra[4:0] r31a andfive
Xmux31a r31a#32 adata[31:0] 0#32 radata[31:0] mux2
Xcheck31b ra2mux[4:0] r31b andfive
Xmux31b r31b#32 bdata[31:0] 0#32 rbdata[31:0] mux2
.ends

//-----------CTL--------------------
.subckt ctl reset z id[31:26] ra2sel bsel alufn[4:0] wdsel[1:0] werf moe wr pcsel[2:0] wasel asel 
Xctl vdd 0 0 id[31:26]    // one read port
+ pcseltemp[2:0] wasel asel ra2sel bsel alufn[4:0] wdsel[1:0] werf moe xwr
+ $memory width=17 nlocations=64 contents=(
+ 0b01110000000000100 // opcode = 0b000000
+ 0b01110000000000100 // opcode = 0b000001
+ 0b01110000000000100 // opcode = 0b000010
+ 0b01110000000000100 // opcode = 0b000011
+ 0b01110000000000100 // opcode = 0b000100
+ 0b01110000000000100 // opcode = 0b000101
+ 0b01110000000000100 // opcode = 0b000110
+ 0b01110000000000100 // opcode = 0b000111
+ 0b01110000000000100 // opcode = 0b001000
+ 0b01110000000000100 // opcode = 0b001001
+ 0b01110000000000100 // opcode = 0b001010
+ 0b01110000000000100 // opcode = 0b001011
+ 0b01110000000000100 // opcode = 0b001100
+ 0b01110000000000100 // opcode = 0b001101
+ 0b01110000000000100 // opcode = 0b001110
+ 0b01110000000000100 // opcode = 0b001111
+ 0b01110000000000100 // opcode = 0b010000
+ 0b01110000000000100 // opcode = 0b010001
+ 0b01110000000000100 // opcode = 0b010010
+ 0b01110000000000100 // opcode = 0b010011
+ 0b01110000000000100 // opcode = 0b010100
+ 0b01110000000000100 // opcode = 0b010101
+ 0b01110000000000100 // opcode = 0b010110
+ 0b01110000000000100 // opcode = 0b010111
+ 0b00000010000010110 // opcode = 0b011000 LD
+ 0b00000110000000001 // opcode = 0b011001 ST
+ 0b01110000000000100 // opcode = 0b011010
+ 0b01000000000000100 // opcode = 0b011011 JMP
+ 0b00000000000000100 // opcode = 0b011100 BEQ
+ 0b00000000000000100 // opcode = 0b011101 BNE
+ 0b01110000000000100 // opcode = 0b011110
+ 0b00001001101010110 // opcode = 0b011111 LDR
+ 0b00000000000001100 // opcode = 0b100000 ADD
+ 0b00000000000101100 // opcode = 0b100001 SUB
+ 0b00000000001001100 // opcode = 0b100010 MUL (optional)
+ 0b00000000000001100 // opcode = 0b100011 DIV (optional)
+ 0b00000000010101100 // opcode = 0b100100 CMPEQ
+ 0b00000000011101100 // opcode = 0b100101 CMPLT
+ 0b00000000110101100 // opcode = 0b100110 CMPLE
+ 0b01110000000000100 // opcode = 0b100111
+ 0b00000001100001100 // opcode = 0b101000 AND
+ 0b00000001111001100 // opcode = 0b101001 OR
+ 0b00000001011001100 // opcode = 0b101010 XOR
+ 0b00000001100101100 // opcode = 0b101011 XNOR
+ 0b00000000100001100 // opcode = 0b101100 SHL
+ 0b00000000100101100 // opcode = 0b101101 SHR
+ 0b00000000101101100 // opcode = 0b101110 SRA
+ 0b01110000000000100 // opcode = 0b101111
+ 0b00000010000001100 // opcode = 0b110000 ADDC
+ 0b00000010000101100 // opcode = 0b110001 SUBC
+ 0b00000010001001100 // opcode = 0b110010 MULC (optional)
+ 0b00000010000000100 // opcode = 0b110011 DIVC (optional)
+ 0b00000010010101100 // opcode = 0b110100 CMPEQC
+ 0b00000010011101100 // opcode = 0b110101 CMPLTC
+ 0b00000010110101100 // opcode = 0b110110 CMPLEC
+ 0b01110000000000100 // opcode = 0b110111
+ 0b00000011100001100 // opcode = 0b111000 ANDC
+ 0b00000011111001100 // opcode = 0b111001 ORC
+ 0b00000011011001100 // opcode = 0b111010 XORC
+ 0b00000011100101100 // opcode = 0b111011 XNORC
+ 0b00000010100001100 // opcode = 0b111100 SHLC
+ 0b00000010100101100 // opcode = 0b111101 SHRC
+ 0b00000010101101100 // opcode = 0b111110 SRAC
+ 0b01110000000000100 // opcode = 0b111111
+ )

// if BNE/BEQ
Xnor id31 id27 nor nor2
Xand id30 id29 id28 nor IFBEQBNE and4

// which bne or beq
// BEQ and Z or BNE and not Z
XswitchPCsel id26 Z which xor2
XbranchZAnd which IFBEQBNE doBranch and2
Xpcselbne doBranch#3 pcseltemp[2:0] 0 0 vdd pcsel[2:0] mux2

// if reset = 1, wr should be 0
Xreset reset xwr 0 wr mux2
.ends


//---------- the whole beta --------------

.subckt knex a b
.connect a b
.ends

.subckt signextend in[15:0] out[31:0]
.connect out[31:16] in[15]
Xknex in[15:0] out[15:0] knex
.ends

.subckt beta clk reset irq ia[31:0] id[31:0] ma[31:0] moe mrd[31:0] wr mwd[31:0]


Xpc clk reset pcsel[2:0] 
+ vdd 0#27 vdd 0 0 0 // xadr = 0x80000008
+ vdd 0#28 vdd 0 0 // illop = 0x80000004
+ radata[31:0] cext[31:0] ia[31:0] cplus[31:0] iaplusfour[31:0] pc

Xctl reset raz id[31:26] ra2sel bsel alufn[4:0] wdseltemp[1:0] werftemp moe wrtemp pcseltemp[2:0] waseltemp asel ctl

Xum ia[31] usermode inverter
Xint irq usermode interrupt and2signextend
Xint1 interrupt#3 pcseltemp[2:0] vdd 0 0 pcsel[2:0] mux2
Xint2 interrupt waseltemp vdd wasel mux2
Xint3 interrupt werftemp vdd werf mux2
Xint4 interrupt#2 wdseltemp[1:0] 0#2 wdsel[1:0] mux2
Xint5 interrupt wrtemp 0 wr mux2

Xregfile clk werf ra2sel id[20:16] id[15:11] id[25:21] wdata[31:0] radata[31:0] mwd[31:0] wasel regfile

Xasel asel#32 radata[31:0] 0 cplus[30:0] adata[31:0] mux2

Xnor01 OUT[3:0] nors01 nor4
Xnor02 OUT[7:4] nors02 nor4
Xnor03 OUT[11:8] nors03 nor4
Xnor04 OUT[15:12] nors04 nor4
Xnor05 OUT[19:16] nors05 nor4
Xnor06 OUT[23:20] nors06 nor4
Xnor07 OUT[27:24] nors07 nor4
Xnor08 OUT[31:28] nors08 nor4

Xnor10 nors01 nors02 nors03 nors04 nor10 and4
Xnor11 nors05 nors06 nors07 nors08 nor11 and4
Xnor20 nor10 nor11 raz and2


Xsign id[15:0] cext[31:0] signextend
Xbsel bsel#32 mwd[31:0] cext[31:0] bdata[31:0] mux2

Xalu alufn[4:0] adata[31:0] bdata[31:0] ma[31:0] z v n alu

Xwdsel wdsel[1]#32 wdsel[0]#32 ia[31] iaplusfour[30:0] mrd[31:0] ma[31:0] 0#32 wdata[31:0] mux4
.ends


